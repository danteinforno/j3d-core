/*
 * $RCSfile$
 *
 * Copyright (c) 2005 Sun Microsystems, Inc. All rights reserved.
 *
 * Use is subject to license terms.
 *
 * $Revision$
 * $Date$
 * $State$
 */

package javax.media.j3d;

import javax.vecmath.*;
import java.util.*;

/**
 * The PickInfo object contains the computed information about a pick hit.  
 * The detailed information about each intersection of the PickShape 
 * with the picked Node can be inquired.  The PickInfo object is constructed with
 * basic information and more detailed information can be generated by setting the
 * appropriate mask to the flag argument in the pick methods of BranchGroup and 
 * Locale.
 * <p>
 *
 * @see Locale
 * @see BranchGroup 
 *
 * @since Java 3D 1.4
 */


public class PickInfo extends Object {
    
    /* The SceneGraphPath of the intersected pickable item */
    private SceneGraphPath sgp;

    /* The intersected pickable node object */
    private  Node node;
    
    /* A copy of LocalToVworld transform of the pickable node */
    private Transform3D l2vw;

    /* The closest intersection point */
    private Point3d closestIntersectionPoint;
 
    /* Distance between start point of pickShape and closest intersection point */
    private double  closestDistance;

    /* An array to store intersection results */
    private IntersectionInfo[] intersectionInfoArr;
    
    /* The following references are for internal geometry computation use only */
    private ArrayList intersectionInfoList = new ArrayList();
    private boolean intersectionInfoListSorted = false;
    private Transform3D l2vwRef;
    private Node nodeRef;
    
    /**
     * Specifies a Pick using the bounds of the pickable nodes.
     */
    public static final int PICK_BOUNDS = 1;
    
    /**
     * Specifies a Pick using the geometry of the pickable nodes.
     */
    public static final int PICK_GEOMETRY = 2;
    
    /**
   * Specifies that this PickInfo returns the computed SceneGraphPath object.
   */
    public static final int SCENEGRAPHPATH  = 0x01;
    
    /**
     * Specifies that this PickInfo returns the computed intersected Node object.
     */
    public static final int NODE = 0x02;
    
    /**
     * Specifies that this PickInfo returns the computed local to vworld transform.
     */
    public static final int LOCAL_TO_VWORLD = 0x04;
    
    /**
     * Specifies that this PickInfo returns the closest intersection point.
     */
    public static final int CLOSEST_INTERSECTION_POINT = 0x08;

    /**
     * Specifies that this PickInfo returns the closest intersection distance.
     */
    public static final int CLOSEST_DISTANCE = 0x10;

    /**
     * Specifies that this PickInfo returns only the closest intersection 
     * geometry information.
     */
    public static final int CLOSEST_GEOM_INFO = 0x20;

    /**
     * Specifies that this PickInfo returns all the closest intersection 
     * geometry informations.
     */
    public static final int ALL_GEOM_INFO = 0x40;


    /** PickInfo Constructor */
    PickInfo() {

    }
    
    void setSceneGraphPath(SceneGraphPath sgp) {
        this.sgp = sgp;
    }
    
    void setNode(Node node) {
        this.node = node;
    }
    
    void setLocalToVWorld(Transform3D l2vw) {
        this.l2vw = l2vw;
    }
    
    void setClosestInteresectionPoint(Point3d cIPt) {
        this.closestIntersectionPoint = cIPt;
    }
    
    void setClosestDistance(double cDist) {
        this.closestDistance = cDist;
    }
    
    void setLocalToVWorldRef(Transform3D l2vwRef) {
        this.l2vwRef = l2vwRef;
    }
    
    void setNodeRef(Node nodeRef) {
        this.nodeRef = nodeRef;
    }
    
    IntersectionInfo createIntersectionInfo() {
        return new IntersectionInfo();
    }
    
    void insertIntersectionInfo(IntersectionInfo iInfo) {
        intersectionInfoList.add(iInfo);
        intersectionInfoListSorted = false;
    }
    
    void sortIntersectionInfoArray(IntersectionInfo[] iInfoArr) {

        class Sort {
	    
	    IntersectionInfo iInfoArr[];

	    Sort(IntersectionInfo[] iInfoArr) {
                System.out.println("Sort IntersectionInfo ...");
		this.iInfoArr = iInfoArr;
	    }

	    void sorting() {
		if (iInfoArr.length < 7) {
                    System.out.println(" -- insertSort.");
		    insertSort();
	    	} else {
                    System.out.println(" -- quicksort.");                    
		    quicksort(0, iInfoArr.length-1);
    		}
	    }

	    // Insertion sort on smallest arrays
	    final void insertSort() {
		for (int i=0; i<iInfoArr.length; i++) {
		    for (int j=i; j>0 && 
                             (iInfoArr[j-1].distance > iInfoArr[j].distance); j--) {
			IntersectionInfo iInfo = iInfoArr[j];
			iInfoArr[j] = iInfoArr[j-1];
			iInfoArr[j-1] = iInfo;
		    }
		}
	    }

            final void quicksort( int l, int r ) {
		int i = l;
		int j = r;
		double k = iInfoArr[(l+r) / 2].distance;

		do {
		    while (iInfoArr[i].distance<k) i++;
		    while (k<iInfoArr[j].distance) j--;
		    if (i<=j) {			
			IntersectionInfo iInfo = iInfoArr[i];
			iInfoArr[i] = iInfoArr[j];
			iInfoArr[j] = iInfo;
			i++;
			j--;
		    }
		} while (i<=j);
		
		if (l<j) quicksort(l,j);
		if (l<r) quicksort(i,r);
	    }
	}

	(new Sort(iInfoArr)).sorting();            
        intersectionInfoListSorted = true;
    }

    static void sortPickInfoArray(PickInfo[] pickInfoArr) {

        class Sort {
	    
	    PickInfo pIArr[];

	    Sort(PickInfo[] pIArr) {
                System.out.println("Sort PickInfo ...");
		this.pIArr = pIArr;
	    }

	    void sorting() {
		if (pIArr.length < 7) {
                    System.out.println(" -- insertSort.");
		    insertSort();
	    	} else {
                    System.out.println(" -- quicksort.");                    
		    quicksort(0, pIArr.length-1);
    		}
	    }

	    // Insertion sort on smallest arrays
	    final void insertSort() {
		for (int i=0; i<pIArr.length; i++) {
		    for (int j=i; j>0 && 
                             (pIArr[j-1].closestDistance > pIArr[j].closestDistance); j--) {
			PickInfo pI = pIArr[j];
			pIArr[j] = pIArr[j-1];
			pIArr[j-1] = pI;
		    }
		}
	    }

            final void quicksort( int l, int r ) {
		int i = l;
		int j = r;
		double k = pIArr[(l+r) / 2].closestDistance;

		do {
		    while (pIArr[i].closestDistance<k) i++;
		    while (k<pIArr[j].closestDistance) j--;
		    if (i<=j) {			
			PickInfo pI = pIArr[i];
			pIArr[i] = pIArr[j];
			pIArr[j] = pI;
			i++;
			j--;
		    }
		} while (i<=j);
		
		if (l<j) quicksort(l,j);
		if (l<r) quicksort(i,r);
	    }
	}

	(new Sort(pickInfoArr)).sorting();        
        
    }

    
    /**
     * Retrieves the reference to the SceneGraphPath in this PickInfo object.
     * @return the SceneGraphPath object, or null if  flag is not set with SCENEGRAPHPATH.
     * @see Locale
     * @see BranchGroup
     */
    public SceneGraphPath getSceneGraphPath() {
	return sgp;
    }

    /**
     * Retrieves the reference to the picked node, either a Shape3D or a Morph, in this PickInfo object.
     * @return the picked leaf node object, or null if  flag is not set with NODE.
     * @see Locale
     * @see BranchGroup
     */
    public Node getNode() {
	return node;
    }

    /**
     * Retrieves the reference to the LocalToVworld transform of the picked node in this PickInfo object.
     * @return the local to vworld transform, or null if  flag is not set with LOCAL_TO_VWORLD.
     * @see Locale
     * @see BranchGroup
     */
    public Transform3D getLocalToVWorld() {
	return l2vw;
    }
	
    /**
     * Retrieves the reference to the closest intersection point in this PickInfo object.
     * @return the closest intersection point, or null if  flag is not set with CLOSEST_INTERSECTION_POINT.
     * @see Locale
     * @see BranchGroup
     */
    public Point3d getClosestIntersectionPoint() {
	return closestIntersectionPoint;
    }

    /**
     * Retrieves the distance between the start point of the pickShape and the closest intersection point.
     * @return the closest distance in double, or NaN if  flag is not set with CLOSEST_INTERSECTION_POINT.
     * Note : If this PickInfo object is returned by either pickClosest or pickAllSorted method, the return
     * value is the closest distance in double even if flag is not set with CLOSET_INTERSECTION_POINT.
     * @see Locale
     * @see BranchGroup
     */
    public double getClosestDistance() {
	return closestDistance;
    }

    Transform3D getLocalToVWorldRef() {
        return l2vwRef;
    }
    
    Node getNodeRef() {
        return nodeRef;
    }
    
    /**
     * Retrieves the reference to the array of intersection results in this PickInfo object.
     * @return an array of 1 IntersectionInfo object if flag is to set  CLOSEST_GEOM_INFO,
     * or an array of <i>N</i> IntersectionInfo objects containing all intersections of 
     * the picked node in sorted order if flag is to set ALL_GEOM_INFO, or null if neither 
     * bit is set.
     * @see Locale
     * @see BranchGroup
     */
    public IntersectionInfo[] getIntersectionInfos() {
   	IntersectionInfo iInfoArray[] = new IntersectionInfo[intersectionInfoList.size()];
	return (IntersectionInfo []) intersectionInfoList.toArray(iInfoArray);	
    }
     
    static PickInfo[] pickAll(Locale locale, GeometryAtom[] geomAtoms,
            int mode, int flags, PickShape pickShape) {

        int pickInfoListSize;
        ArrayList pickInfoList = Picking.getPickInfo(null, null, geomAtoms,
                locale, flags);
        
        // We done with PICK_BOUNDS case, but there is still more work for PICK_GEOMETRY case.
        if((mode == PICK_GEOMETRY) && ((flags & PickInfo.CLOSEST_DISTANCE) != 0) &&
                ((flags & PickInfo.CLOSEST_INTERSECTION_POINT) != 0) && 
                ((pickInfoListSize = pickInfoList.size()) > 0)) {
            
            PickInfo pickInfo = null;
            Node node = null;
            
            // Need to do in reverse order.    
            for(int i = pickInfoListSize - 1; i >= 0; i--) {
                pickInfo = (PickInfo) pickInfoList.get(i);
                
                if (node instanceof Shape3D) {
                    if (((Shape3DRetained)(node.retained)).intersect(pickInfo, pickShape, flags) == false) {
                        pickInfoList.remove(i);
                    }
                } else if (node instanceof Morph) {
                    if (((MorphRetained)(node.retained)).intersect(pickInfo, pickShape, flags) == false) {
                        pickInfoList.remove(i);                        
                    } 
                }
            }
        }

        PickInfo[] pickInfoArr = new PickInfo[pickInfoList.size()];
        return (PickInfo []) pickInfoList.toArray(pickInfoArr);
        
    }
    
    
    /**
     * The IntersectionInfo object holds extra information about an intersection 
     * of a PickShape with a Node as part of a PickInfo. Information such as 
     * the intersected geometry, the intersected point, and the vertex indices 
     * can be inquired.  
     * The local coordinates, normal, color and texture coordiantes of at the
     * intersection can be computed, if they are present and readable, using the 
     * interpolation weights and vertex indices.
     * <p>
     * If the Shape3D being picked has multiple geometry arrays, the possible arrays
     * of IntersectionInfo are stored in the PickInfo and referred to by a geometry 
     * index. If the picked geometry is of type, Text3D or CompressGeometry, 
     * getVertexIndices is invalid. If the picked Node is an Morph 
     * object, the geometry used in pick computation is alway at index 0.
     * <p>
     *
     * @since Java 3D 1.4
     */				    
    
    public class IntersectionInfo extends Object {
	
	/* The index to the intersected geometry in the pickable node */
	private int geomIndex;

        /* The reference to the intersected geometry in the pickable object */
	private Geometry geom;

	/* The intersection point */
	private Point3d intersectionPoint;

	/* Distance between start point of pickShape and intersection point */
	private double  distance;

	/* The vertex indices of the intersected primitive in the geometry */   
	private int[] vertexIndices;

	/* The interpolation weights for each of the verticies of the primitive */
	// private float[] weights;  Not supported. Should be done in util. package  

	/** IntersectionInfo Constructor */
	IntersectionInfo() {

	}

        void setGeometryIndex(int geomIndex) {
            this.geomIndex = geomIndex;
        }
        
        void setGeometry(Geometry geom) {
            this.geom = geom;
        }
        
        void setIntersectionPoint(Point3d intersectionPoint) {
            this.intersectionPoint = intersectionPoint;
        }
        
        void setDistance(double distance) {
            this.distance = distance;
        }       
        
        void setVertexIndices(int[] vertexIndices) {
	    this.vertexIndices = vertexIndices;
	}

        
	/**
	 * Retrieves the index to the intersected geometry in the picked node, either a Shape3D or Morph.
	 * @return the index of the intersected geometry in the pickable node.
	 */
	public int getGeometryIndex() {
	    return geomIndex;
	}

	/**
	 * Retrieves the reference to the intersected geometry in the picked object, either a Shape3D or Morph.
	 * @return the intersected geometry in the pickable node.
	 */
	public Geometry getGeometry() {
	    return geom;
	}

	/**
	 * Retrieves the reference to the intersection point in the pickable node.
	 * @return the intersected point in the pickable node.
	 */
	public Point3d getIntersectionPoint() {
	    return intersectionPoint;
	}

	/**
	 * Retrieves the distance between the start point of the pickShape and the 
	 * intersection point.
	 * @return distance between the start point of the pickShape and the 
	 * intersection point.
	 */
	public double getDistance() {	    
	    return distance;
	}
        
	/**
	 * Retrieves the vertex indices of the intersected primitive in the geometry.
	 * @return the vertex indices of the intersected primitive.
	 */
	public int[] getVertexIndices() {
	    return vertexIndices;
	}

    }
}


